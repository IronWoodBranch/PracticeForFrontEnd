12/19 day1
把json变成页面：以前的方式：用dom，把json整到页面里，操作麻烦，性能低下，现在抛弃原生dom
rest服务器：负责提供model，模型
浏览器：负责提供views
把model镶嵌到views的东西叫view-model，view model负责连接视图和数据，数据发生变化，view就变化
这就是mvvm架构 model view view model
传统的view model实现方式：没有，原生DOM
JS框架主要解决的问题：使用DOM渲染页面的时候，麻烦性能低；vue react angular都是替换DOM的

vue的官方文档介绍：渐进式声明式组件化编程模型；
声明式：对应命令式，面向过程
组件化：把网页更加细分，拆分成很多不同部分，好处：组装式编程，提高复用性，最小单位不再是网页
渐进式：可大可小

vue主要功能：替换掉dom，不再需要原生dom操作，mvvm操作模式，vue负责vm(view model，视图模型)的工作
关联视图和模型，当模型变化时，视图会自动更新，当视图去操作模型（双向绑定）
view的特点：1.组件化开发，2.声明式编程

一切皆组件
根组件和其他组件：
写代码的时候需要先创建根组件

在vue3中，组件就是一个js对象（惊）
大写字母开头表示构造函数，组件正好对应组件实例
D:\TsCode\PracticeForFrontEnd\vue\vue_practice\01_brief\01_usingDirectly笔记看这

组件是用来创建组件实例的，也就是vm，不直接用组件是为了复用，组件实例之间不会互相干扰

template会覆盖原生网页
component：里面放子组件的名字
template原理：项目运行的时候，模板会被转换成函数，然后被运行，所以在模板中写h5，性能更差
单文件组件就是为了解决template的种种不便产生的解决方案：App.vue

window.vm=vm   这是全局变量

public：静态资源根目录
12.24 day2
P10
根组件只能挂载一个
组件实例（用createApp创造出来的实例）一般命名为vm（view model）
组件实例的类型：Proxy(代理对象)
箭头函数没有this，可能因为本质是一个匿名函数，且为一次性的，当即销毁，
所以，vue的时候减少使用箭头函数

响应式数据：
在vue中，被data return出去的数据是响应式数据

P11，12响应式原理-代理对象
vue如何实现响应式：
代理
    细节:handler用来处理代理行为，是一个对象{}
        new Proxy(对象，handler)
        Proxy构造函数是被封装好的，（不知道是js还是vue封装的），即便传入空的handler，第一个参数对象
    也会具有响应式的特点
结论： 
    data中return的对象，本质上是被vue代理了，所以实现了响应式
小细节
P13 data详解
    1.data()老老实实返回{}，不要返回对象名，不然所有子组件会共用
    2.深层响应对象
        data()中所有的属性都被遍历，全响应
    3.有时候需要浅层响应对象
        去文档找shallowReactive的用法
    4.它的应用场景呢？
        一般不需要，主要为了节约性能
    5.开发建议：
        不用的属性也先在data（）中给它返回，因为vue有响应式的特点，后期需要的时候直接赋值
    最终达到有就显示没有就不显示的效果
P14 methods
1.methods和components差不多，里面放的不是组件而是方法
    methods方法会自动挂在到根组件上
P15 计算属性
1.细节
    computed，和component还有methods同一层级，里面是属性和它的getter方法
    tips：操作对象时，记得this
2.重要：会对数据进行缓存
    computed只会在数据变化时进行计算

P16 计算属性的setter：不建议这么做，逻辑会变得复杂
1.凡是需要计算出来的属性，尽量设置为计算属性
2.使用计算属性的setter
    set()，计算属性被修改的时候就会调用

P18 组合式api和选项式api
1.setup()
    是钩子函数，可以通过setup向外界暴露组件的配置
    
    细节：
    组件信息写到这个钩子函数里面，vue会调用setup

2.setup中，用return来决定哪些内容要暴露给外部

3.组合式api中直接声明的变量*不具有响应式*，是普通变量

4.导入reactive来创建响应式变量
    eg.const stu = reactive({
        xxx:1,
        bbb:2
    })
P19 setup优化
1.<script setup>后，默认所有的东西都在setup，直接开始面向过程编程

P20 响应式代理

P21 _ref对象解包
    想要修改被ref代理？的值，要改.value
1.yarn启动项目的步骤
    1.yarn create vue（需求：node版本）
        
    2.删除components文件夹和app.vue中引用的css
    3.package.json中，dev 在vite 后面加--open
    4.yarn（添加依赖）
    5.yarn dev
2.ref用于基本类型，reactive用于对象

3.在template中，ref对象如果是顶层对象，就会自动解包，否则需要手动解

P22 模板语法
1.在模板中，可以直接访问到组件中声明的变量
    {{}}

2.除了组件变量，vue提供了一些全局变量，例如Date,Math

3.除此之外，也可以通过vue添加全局变量
    app.config.globalProperties

4.插值语法（双大括号）只能使用表达式
    表达式：有返回值的语句，能用变量接收的就是表达式

5.插值语法的原理：修改元素的textContent

6.h5代码用``包裹

7.v-text的作用：等同于{{}}，本质是把传入的值作为5中的textContent插入
8.v-html，类似7，但是是把表达式的值作为innerHtml使用，有被xss攻击的危险

9.静态目录内容会被打包进dist，也就是根目录里面，在调用的时候直接/就行

P23 vbind
1.{{}}插值不能用在标签里面，想要在标签里面用变量只能用v-bind

2.v-bind可以直接给对象

3.v-bind的布尔值属性时，遵循js规则，0=false NaN=false ，任意值=true,""空串为真

4.v-bind另一个用法
    const a = "title"
    const b ="toilet"
    eg.<img v-bind:[a] = b>
    就是title属性值设为toilet

p24 style-scoped
1.style和script，template同级，style添加scoped可以变为局部
原理：vue自动为组件中的所有元素生成了一个随机的属性

2.随机生成的书信，除了添加到当前组件上，还会传染到当前组件引入的别的组件上
p25 style-module
用得少，还是用scoped
1.加了之后，会对模块中的类名哈希化，使用方法  ：$style
2.使用方法2，module指定类名，然后div:class ="module类名.div名"来使用

